### Design Patterns

#### Decorator

- 新しい振る舞いや責務を追加するためにオブジェクトをラップする。

#### Adaptor

- 相互性のない interface のためにそのままでは連携できないクラスを連携させる。つまり interface を連携できる形へ変換するためにオブジェクトをラップする。

#### Facade

- サブシステムの一連のインターフェースに対する、連続されたインターフェースを提供。ファサードは、サブシステムをより使いやすくする高水準インターフェースを定義する。(クライアントを複雑なサブシステムから分離する)

#### Template method

- アルゴリズムの手順を定義し、１つ以上の手順をサブクラスで提供できるようにする（共通部分を汎化する。スーパークラスはアルゴリズムに関する知識に集中し、完全な実装の提供をサブクラスに任せる。）
  - 特徴としては、スーパークラスがアルゴリズムを完成させるためには、サブクラスの実装が必要である場合。また具象クラスで実装する場合だけではなく、単にアルゴリズムの一部を補間する役割を他のコードに先送りする場合も Template method と見なすことができる。

#### Iterator

- `hasNext()`: アグリゲート内に反復処理を行う要素がさらにあるかどうかを通知
- `next()`: アグリゲートないの次のオブジェクトを取得

#### Composite

- ツリー構造的文脈で言うと、全ての`ノード`と`リーフ`は同じインターフェースから作成される。つまり全て同じコンポネントであると言える。Composite pattern では`ノード`は`Composite`と呼ばれる。

### 設計原則

- `Principle of Least Knowledge` : オブジェクト間のやりとりを少数の身近な「友達」だけに減らすようにする

```java
// NO!!!
public float getTemp(){
  Thermometer thermometer = station.getThermometer();
  return thermometer.getTemperature(); // 友達の友達を読み出さない
}
// YES!
public float getTempt(){
  return station.getTemperature(); // 依存するクラス数を減らす
}
```

### 用語

- `Component`: インスタンス変数で参照されるあらゆるオブジェクト。言い換えれば、`has-a`関係である。
- `hook`: デフォルトで何もしないメソッド。 サブクラスはオーバーライドしないといけないわけではないため`フック`と呼ばれる。
  - アルゴリズムの一部がオプションである場合は hook を使う
- `Collection`: 単なるオブジェクトの集合を意味する。これらは list, array, hashtable など様々なデータ構造に格納される可能性がある。時に `Aggregate` と呼ばれることもある。
